import fsExtra from 'fs-extra';
import path from 'path';

import symbols from './symbols';

export interface TSDKConfig {
  packageDir: string;
  packageName: string;
  /** ['typeorm', 'kysely'] */
  entityLibName: string | string[];
  baseDir: string;
  entityExt: string;
  apiconfExt: string;
  shareExt?: string;
  sharedDirs: string[];
  /**
   * no need delete files in `fe-sdk/src`
   */
  sdkWhiteList: string[];
  monorepoRoot?: string;
  /** 
   * remove unnecessary filelds after build in *.apiconf.js 
   * @default
   *  [
      'needAuth',
      'category',
      'name',
      'description',
      'type',
    ]
   */
  removeFields?: string[];
}

export const comment = `
/**
 * This is auto generated by \`tsdk\`.
 * Don't edit this file.
 */
`;

let id = 0;

export const getDefaultContent = () =>
  `/** This line auto generated by \`tsdk\` and this will be removed if have content. */\nexport const test_${++id} = ${++id};`;

export const currentConfigFilePath = path.join(process.cwd(), '.tsdkrc.json');
export const isCurrentConfigExist = fsExtra.existsSync(currentConfigFilePath);

export const config: TSDKConfig = {
  ...JSON.parse(
    fsExtra.readFileSync(
      path.join(__dirname, '..', 'fe-sdk-template', 'config', '.tsdkrc.json'),
      'utf-8'
    )
  ),
  ...(isCurrentConfigExist ? JSON.parse(fsExtra.readFileSync(currentConfigFilePath, 'utf-8')) : {}),
};

let hasTypeORM = false;
let hasKysely = false;
if (!config.entityLibName) {
  config.entityLibName = ['typeorm', 'kysely'];
} else {
  if (!Array.isArray(config.entityLibName)) {
    config.entityLibName = [config.entityLibName];
  }

  hasTypeORM = Boolean(config.entityLibName.find((i) => i === 'typeorm'));
  hasKysely = Boolean(config.entityLibName.find((i) => i === 'kysely'));

  if (!hasKysely && !hasTypeORM) {
    console.log(
      symbols.error,
      'currently `entityLibName` only support `typeorm` and `kysely`, but your choice is `' +
        config.entityLibName +
        '`'
    );
  }
}

export { hasTypeORM, hasKysely };

// example: ./src => src
config.baseDir = path.normalize(config.baseDir);

function getPackageFolder(name: string) {
  if (name[0] === '@') {
    return name.split('/')[1];
  }
  return name;
}

export const packageFolder = getPackageFolder(config.packageName);
export const ensureDir = path.join(
  `${path.join(...config.packageDir.split('/'))}`,
  `${packageFolder}`
);

const tsconfigPath = path.join(process.cwd(), 'tsconfig.json');
export const tsconfigExists = fsExtra.pathExistsSync(tsconfigPath);

try {
  tsconfigExists && JSON.parse(fsExtra.readFileSync(tsconfigPath, 'utf-8'));
} catch {
  console.log('\n', symbols.error, '`tsconfig.json` must be a valid JSON file.', '\n');
}

export const tsconfig = tsconfigExists
  ? JSON.parse(fsExtra.readFileSync(tsconfigPath, 'utf-8')).compilerOptions
  : {};

let deps: { [key: string]: string } = {};

export const pkg: { [key: string]: string } = {};

export async function parsePkg() {
  const content = await fsExtra.readFile(path.join(__dirname, '..', 'package.json'), 'utf-8');
  Object.assign(pkg, JSON.parse(content));
  return pkg;
}

export async function parseDeps() {
  const content = await fsExtra.readFile(path.join(ensureDir, 'package.json'), 'utf-8');
  const pkgJSON = JSON.parse(content);
  Object.assign(pkg, pkgJSON);
  deps = {
    ...pkgJSON.dependencies,
    ...pkgJSON.devDependencies,
    ...pkgJSON.peerDependencies,
  };
}

export function getDeps() {
  return deps;
}
